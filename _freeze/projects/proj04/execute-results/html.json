{
  "hash": "c7ec4d74728b8c9dcf05ba32858177f0",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Project 04: More Vec Operations\"\nformat: \n  html:\n    css: /projects/proj-styles.css\n---\n\n\n\n\n<center>\n\n<figure>\n\n<img src=\"/images/projects/proj04-header.jpeg\" alt=\"Created by AI Prompt: a C++ array fading away\" width=\"350\"/>\n\n<figcaption>Created by AI Prompt: *a C++ array fading away*</figcaption>\n\n</figure>\n\n</center>\n\n## Project 4: More Vec Operations\n\n## Objectives\n\n1.  Build more vector operations.\n2.  Practice using the debugger (if necessary).\n\n## Step 0. Prepare\n\n::: callout-important\n## READ THIS: IT IS DIFFERENT THAN NORMAL!\n:::\n\n-   [Click the link](){target=\"_blank\"} and then \"Accept this assignment\".\n-   Wait a few seconds and refresh the page. Refresh until the page says \"You're ready to go!\". The page has a link to a github repo.\n-   Click the link to see your new repo on github.com.\n-   Click the green [**Code**]{style=\"color:green\"} button and copy the link it shows.\n-   In a terminal,\n    -   `cd` to the directory where you are putting all your CS112 assignments.\n    -   type `git clone paste-the-contents-of-the-link-you-copied`\n-   `cd` to the new directory containing your repo.\n\n::: callout-important\n## BECAUSE your project depends on your lab code, you need to copy your lab code over to this repo. In a terminal:\n\n-   `cd` to your **lab04** directory (use `pwd` to make sure you are in the right directory)\n-   `cp Vec.h Vec.cpp your-project-directory` (the full path to your project 4 directory)\n-   `cd` to your project 4 directory\n:::\n\n::: callout-warning\nIf, at this moment in the course, you are still not able to handle directories and files using the terminal, spend some time searching more about it and learning. This is an essential skill for anyone who handles computational systems nowadays. [This might be a good place to start](https://www.youtube.com/watch?v=42iQKuQodW4){target=\"_blank\"}.\n:::\n\n-   Open your project in VS Code, and open **Vec.h**\n-   Add this prototype for the assignment operator to **Vec.h**, in the public area:\n\n``` cpp\nVec& operator=(const Vec& original);\n```\n\n-   Add this code to **Vec.cpp**:\n\n``` cpp\nVec& Vec::operator=(const Vec& original) {\n    if (this != &original) {\n        if (mySize != original.mySize) {\n            if (mySize > 0) {\n                delete[] myArray;\n                myArray = nullptr;\n            }\n            if (original.mySize > 0) {\n                myArray = new Item[original.mySize];\n            }\n            mySize = original.mySize;\n        }\n        for (int i = 0; i < mySize; ++i) {\n            myArray[i] = original.myArray[i];\n        }\n    }\n    return *this;\n}\n```\n\n-   In the terminal, type `make tester`\n-   The code should compile and give you an executable called \"tester\"\n-   Run the tester file: `./tester`\n-   Your tests should all pass.\n\n## Step 1. Introduction\n\nThis week's project adds more functionality to the Vec class we built in the lab. To illustrate, suppose that `v1`, `v2`, and `v3` are Vec objects containing the following values:\n\n``` cpp\nv1 == {1, 2, 3}\nv2 == {2, 4, 6}\nv3 == {1, 2, 3}\n```\n\n### 1.0 Subscript\n\nThe subscript operator (`[i]`) can be implemented such that using subscripting on the left-hand-side of an assignment (i.e., setting a value in the array) and using subscripting on the right-hand-side (i.e., getting a value in the array) both work. Thus, the method will be similar to both `setItem(i)` and `getItem(i)`.\n\n-   Normally, the subscript operation on an array **does not** perform bounds checking on the index value i, but yours should perform bounds checking. More precisely, your subscript operator should throw a `range_error` if it is passed a \"bad\" index value.\n-   The method should return a **reference** to the item in the array.\n\nHere is the algorithm:\n\n``` cpp\nItem &operator[](unsigned index)\n    check if index is legal. If not, throw a range_error\n    return myArray[index];\n```\n\nBecause the method is returning a reference to the item in the array, subscripting works for both sides of an assignment.\n\n### 1.1 Const subscript\n\nIf a Vec object is defined as constant then indexing the array in the Vec must also be constant -- i.e., it cannot allow code to change the array. In **tests.cpp**, see a function called `testConstSubscript()`. This function takes a const-ref parameter. The subscripting of that Vec parameter will require us to implement the const subscripting method. The code in the method is identical to the code you wrote in the previous step above, but it returns `const Item &`, and is a const method -- i.e., has `const` on the end of the line. Implement that method now so that all subscripting tests pass.\n\n::: callout-note\nThe function `testConstSubscript()` can be found on line 315 in **tests.cpp**. Make sure you uncomment the function and the following `TEST_CASE(\"subscript\")` and run `make tester && ./tester` before proceeding. You should have 131 assertions in 11 test cases passed at this point.\n:::\n\n### 1.2 Vector Addition\n\nThe expression:\n\n``` cpp\nv3 = v1 + v2;\n```\n\nshould set `v3 == {3, 6, 9}`, without leaking memory.\n\nWhen C++ compiles `v1 + v2`, it looks at the types of the values that surround the `+`. It sees that `v1` is a Vec object, so it actually will call `operator+()` on the `v1` object, passing `v2` as the parameter. Thus, the prototype is \n\n```cpp\nVec Vec::operator+(const Vec &rhs) const\n```\n\n`v1` is the \"this\" object that `operator+` is being called on. `v2` is being passed in as the **rhs** (right-hand-side) parameter.\n\nImplement it. The implementation is quite simple: make sure the sizes of the two Vecs are the same. If not, throw an error of type `invalid_argument`. If they are the same, create a new Vec object (of the correct size) and loop, repeated adding the values from `myArray[i]` and `rhs[i]` together and putting the result into the new Vec object.\n\n:::{.callout-note}\nUncomment the `TEST_CASE(\"addition\")` in line 344 to test if your code works. Do not move foward if you get errors.You should have 139 assertions in 12 test cases passed at this moment.\n:::\n\n### 1.3 Vector Subtraction\n\nThe expression:\n\n``` cpp\nv3 = v1 - v2;\n```\n\nshould set `v3 == {-1, -2, -3}`, without leaking memory.\n\n\n:::{.callout-note}\nTo make life easier for you, **tests.cpp** contains tests for each this operation also (`TEST_CASE(\"subtraction\")`). Use these tests and test-driven development to build your operations. If you get your program to compile, but it fails a test and you cannot figure out what is wrong, **use the debugger**! If necessary, draw a memory diagram and trace through the execution of the problematic function one statement at a time, until you identify the logic error. At this point, you should have (all going well) 147 assertions in 13 test cases passed.\n:::\n\n## Step 2. Application\n\nCongratulations! ðŸŽ‰ðŸŽ‰ðŸŽ‰ðŸŽ‰ You have been named the navigation officer on the starship **U.S.S. Boobyprize**, whose hyper-spatial engines allow the ship and its crew to explore the universe. Current theories suggest that reality consists of 11 or more dimensions, so you need a program to help you navigate through an N-dimensional space.\n\nVectors can be used to store positions (and/or directional forces) in a coordinate system. Vectors of length 2 can be used to store 2-dimensional (x, y) information; vectors of length 3 can be used to store 3-dimensional (x, y, z) information; and so on. Your task is to write a program that:\n\n1.  Prompts for and has the user enter the number of dimensions in their space, storing this number in a variable N, which it can then use to define vector objects.\n2.  Prompts for and has the user enter a starting position in that space, and stores that position in a vector object sum.\n3.  Uses a loop that:\n    1.  prompts for and has the user enter a position (relative to their current position), and stores that position in a vector,\n    2.  adds that vector to the sum vector.\n4.  This loop should let the user enter an arbitrary number of positions.\n5.  Outputs the starting position plus the final position (i.e., the sum of the positions from the accumulator-vector).\n\nFor example, if the user is in a 3-dimensional system, enters the starting point {0, 0, 0}, and then enters the following four 3-dimensional relative-positions:\n\n```{1, 0, 0}\n{0, 1, 0}\n{0, 0, 1}\n{1, 2, 3}\n```\n\nthe program should then display the starting position (`{0,0,0}`) and the sum from the accumulator (`{2, 3, 4}`), which is the user's final position within the 3-dimensional system.\n\nAs another example, if the user is navigating through a 5-dimensional space, enters `{1, 0, 1, 0, 1}` as the starting point, and enters three 5-dimensional relative-positions:\n\n```{0, 1, 0, 1, 0}\n{2, 2, 2, 2, 2}\n{-3, -3, -3, -3, -3}\n```\n\nthe program should then display the starting position and the final position (`{0, 0, 0, 0, 0}`).\n\n::: callout-note\nYou may (if you wish) have your program display the starship's new position each time it is updated, rather than just displaying the final position at the end.\n:::\n\nYour application should have the user enter the vectors in the format expected by your `readFrom(istream&)` method: numbers separated by whitespace. (It does not have to parse through curly-brace and comma characters.) Likewise, your application can display the starship's position using the format provided by your `writeTo(ostream&)` method -- numbers separated by spaces.\n\nTo get you well on your way, your repo contains **App.cpp** and **App.h**. These files provide most of what you have to implement to finish this project. Just implement the missing TODO parts.\n\nNow that you have addition implemented, you'll need to uncomment the line in **App.cpp** that reads\n\n``` cpp\nres = res + v;\n```\n\nYou will have to edit `main()` in **main.cpp** to:\n\n1.  call the `App()` constructor, and then\n2.  on the resulting object, call `run()`.\n\nCompile the program with `make proj4` and execute the program by doing `./proj4`.\n\n## Submit\n\nSubmit your changes using git, either from the command line or using VSCode. Push your changes up to github.\n\nVerify you have synced your code to github by going to your online repo webpage and looking to see that the files are correct.\n\nVerify that the autograding tests have successfully passed in github.\n\n## Grading Rubric\n\n30 pts Total:\n\n-   Passes all tests: 8 pts.\n-   `operator[]`: 3 pts\n-   `operator+`: 3 pts\n-   `operator-`: 3 pts\n-   USS Boobyprize application: 10 pts\n-   Code is clean and neat. Comments where appropriate, good spacing, etc: 3 pts.\n\nWays students lost points in the past:\n\n-   -1: Const-qualified subscript operator \\[\\] should return `const Item&`, not `Item&`;\n-   -3: Your `readFrom()` implementation never stops reading from input, so the app doesn't work\n-   -2: Missing call into `App::run()` from `main()`. <!-- + -15 (50%) for 5 days late. -->\n-   -2: Dynamically allocate the new vectors in addition and subtraction causes memory to leak\n-   -2: Did not uncomment the line that adds each vector to the result in `App.cpp`, so it doesn't work\n-   -2: Needs two versions of the subscript operator for const and non-const\n-   -2: `setSize()` was not fixed from the lab, tests do not pass\n\n",
    "supporting": [
      "proj04_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}